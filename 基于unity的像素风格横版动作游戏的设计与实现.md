# 基于unity的像素风格横版动作游戏的设计与实现

## 1 绪论

自1952年电子游戏面世以来，开发电子游戏的成本与日俱增。到如今，现代电子游戏产业高度工业化，开发电子游戏不再是一个人或者一小群人的艺术工作，而是与投资和回报密切相关的商业行为。2000年左右“独立游戏”的概念诞生，它描述了一类开发经费少，参与制作人数不多，作品具有创新的概念和实验性的玩法的游戏。2000年的RPG Maker、2005年左右的Unreal3、Unity3D等游戏引擎的面世使得开发独立游戏的成本大大降低，使得“一个人开发游戏”真正成为可能。

优秀的极少人开发的独立游戏有很多，例如高瞰的《去月球》、team cherry的《空洞骑士》（3人）、Joakim Sandberg的《叛逆机械师》、此外还有著名的《时空幻境》、《FEZ》、《超级食肉男孩》等等。事实证明一个人开发游戏是可行的。

本文旨在叙述和梳理在unity环境下，一类独立游戏的设计流程和开发实现。对设计上和实现上的具体问题进行研究探讨。

### 1.1 Unity

Unity3D是由Unity Technologies开发的一个让玩家轻松创建诸如三维视频游戏、建筑可视化、实时三维动画等类型互动内容的多平台的综合型游戏开发工具，是一个全面整合的专业游戏引擎。

本文选择unity基于如下理由：

1. 成熟的开发工具，完善的文档和教学材料，使得上手简单；
2. 庞大的用户社区，容易解决问题；
3. 对2d的支持良好，有很多常用的开发套件；
4. 对个人开发者免费。
5. 跨平台支持良好

### 1.2 像素风格

像素风格是一种在高分辨率显示设备上使用放大的点阵图作为素材的美术风格。

电子游戏发展早期，游戏载体的机能限制导致开发者无法追求游戏的画面表现，只能在游戏性上做文章，如早期的街机框体、雅达利家用机等。之后一段时间里，游戏行业发展日新月异，新的高性能游戏机的出现使得追求游戏的画面表现成为可能。任天堂的FC是8位机，世嘉MD和任天堂SFC是16位机，在这一段历史时期里，游戏开发者们探索出了一系列高效的像素图像表现方法，创造出了一大批经典游戏。这使得“像素风格”成为一代人的共同记忆。索尼Playstation、世嘉土星等32位主机面世之后，3d画面成为游戏行业热门，2d游戏式微，所以直到现在，人们常使用"8bit风格"、"16bit风格"来形容那些类似8bit游戏机和16bit游戏机画面表现的游戏。

如今像素风格不再是受限于机能的妥协方案，而是自成一派的艺术风格，受到上至大型游戏厂商下至独立作者的青睐。使用像素风格的主要理由有：

1. 素材绘制相对简单。游戏作者可以把时间成本从素材绘制中解放出来，转而投入到游戏逻辑实现上。也因为这一点，像素风格或多或少成为了“游戏性”的象征。
2. 资源占用少。一些沙盒游戏（如Minecraft、Terraria）地图及其庞大，如果使用高清资源会占用大量内存资源，而使用像素素材则可以减少内存开销，以此构建更大的场景。
3. 动画流畅、明快。一些动作游戏或格斗游戏（如拳皇13）追求人物动作的流畅、精准，从而使用像素素材。一些动画为了表现力还会实现画面扭曲等特效，如果使用3d画面反而会降低表现力。

像素风格不仅是审美复古，还是一种可靠的解决方案，时至今日，即使人们都在使用高性能游戏机和高分辨率显示器，像素风格的游戏仍然长盛不衰。

### 1.3 横版动作游戏



### 1.4 实例介绍



## 2  Unity引擎使用

### 2.1 游戏对象和场景

游戏对象（game object）是游戏中所有实体的基本载体。游戏对象上可以搭载各类组件（component）来获得指定的功能。例如可以搭载图片渲染器组件（sprite renderer）来指定该游戏对象为一张图片，可以搭载相机组件（camera）来指定该游戏对象为相机等等。通过这种方式可以获得游戏内容所需的所有对象。例如灯光、粒子、动画、物理刚体等等。此外游戏脚本程序（mono behaviour）也依附游戏对象存在。

游戏对象可以通过名为形态（transform）的组件连接，该组件是默认存在的，它指定了不同对象之间的连接关系，使多个游戏对象可以形成树状结构。transform组件控制了游戏对象在世界坐标中的位置。当一个对象的位置改变了，它的所有子对象会随之改变。

unity引擎中，一个场景（scene）包含了实现一部分完整游戏内容的所有要素。也就是说，在一些游戏设计里面，同一时间内的内存中可以只存在一个场景，而达成完整游戏功能。场景是由若干棵游戏对象树组成的。

由于一次性把所有游戏资源放入内存的开销太大，所以场景应当只包含当前所需要的内容。例如一个关卡适合用一个场景来描述，而切换关卡时可以创建新的场景，销毁现有场景，达到节约内存的目的。unity引擎允许多个场景同时存在，这使得一些类似于“无缝大地图”的设计模式可以实现。根据玩家所处位置，动态加载相邻的场景，销毁远处场景，即可场景间的无缝切换。

### 2.2 视觉表现

#### 2.2.1 渲染引擎

#### 2.2.2 动画系统

#### 2.2.3 粒子系统

#### 2.2.4 光照系统

#### 2.2.5 相机

#### 2.2.6 物理引擎

### 2.3 音效

### 2.4 脚本控制

#### 2.4.1 脚本运行机制

#### 2.4.2 Unity API

### 2.5 Unity工作流

## 3 像素风格实现

如今“像素风格”的定义是见仁见智的。最基本的，游戏视觉表现要以肉眼可见的像素块作为载体，并且不使用混叠（帧之间的柔和过渡）和过滤器（素材抗锯齿），而在此之上，又有许多额外讲究，例如：

1. 是否是完美像素
2. 是否是8bit或16bit色彩
3. 动画帧数是否统一

以追求画面美观、流畅为标准，本项目采用完美像素，使用32bit真彩色，不统一动画帧数。

### 3.1 像素风格实现原理

### 3.2 相对分辨率

相对分辨率是用来确定画面放大倍数的一个数值，它描述了游戏主要画面的大小。

指定一个相对分辨率(a,b)，获取游戏设备屏幕大小(x,y)，求得min([x/a],[y/b])即为放大的倍率。也就是说，在条件允许的情况下尽量使主要游戏画面占据更多的屏幕位置。

使用相对分辨率可以解决一系列适配问题，开发时只需要关心相对分辨率内的情况。

### 3.3 完美像素

完美像素指素材之间像素对齐。在低分辨率的开发引擎或者显示设备上，例如fc、gba平台上，像素对齐是很自然的。然而在高清平台上模拟的像素化画面中，像素对齐是需要注意的事情。在游戏引擎中，各种游戏对象的速度、位置等信息都是浮点数信息，投射到屏幕上之后也是精度很高的画面，如何将放大后的游戏画面有效对齐，各个游戏引擎有不同的做法，这里以unity为例进行介绍。

### 3.4 完美像素在Unity下的实现

#### 3.5.1 Pixel Per Unity

Pixel Per Unity（PPU）是unity环境下作用于2d图片素材文件的一项参数。其含义是：unity坐标系统中每单位长度对应了多少像素。它是对图片像素块大小的限定和统一。在处理素材文件时，理应确保所有素材的PPU的值一致。一般来讲，像素素材文件的分辨率、PPU以及相机的正交大小都最好是2的幂次方。

#### 3.5.2 素材参数

除了PPU之外，unity的2d素材对象还有许多有关像素化的参数，通过对这些参数的修改可以确保素材层面的像素化。

1. Filter Mode，滤波模式。为了使图片平滑柔和，untiy会将2d素材进行滤波处理，处理之后的图片会变得模糊。如果素材为像素素材，则设置滤波模式为Point模式。
2. Compression，压缩。使用压缩算法对图片进行压缩，以减少内存开销。压缩后图片的色彩和边缘细节等都会受到不同程度的损失，这种损失在像素素材放大之后尤为明显，所以将压缩参数设置为None。
3. Pivot Unit Mode，轴心选取。unity中游戏对象的移动是根据对象中心点坐标决定的，这项参数表明了图片资源的什么位置是中心点。将这里的参数设置为Pixels，图片的轴心点会取决于像素，而不是取决于图像上每个轴从0到1的平滑范围。如果图片不根据像素确定轴心，像素清晰度会下降。

#### 3.5.3 完美像素相机插件

完美像素相机（Pixel Perfect Camera）是一个作用于camera组件的第三方组件。将 Pixel Perfect Camera 组件添加到 Unity 的 Camera 对象上，它会加强 Camera 对象的功能。



#### 3.5.4 脚本控制

## 4 像素艺术

### 4.1 像素线条

#### 4.1.1 线条柔化

#### 4.1.2 边框

#### 4.1.3 抗锯齿

### 4.2 像素色彩

#### 4.2.1 索引颜色模式

#### 4.2.2 像素色彩选择

#### 4.2.3 调色板

### 4.3 像素动画

#### 4.3.1 动画

#### 4.3.2 特效动画

#### 4.3.3 粒子特效

### 4.4 软件工具

#### 4.4.1 Aseprite

#### 4.4.2 Pyxel Edit

#### 4.4.3 Photo Shop

## 5 游戏形式和内容设计

本章介绍本项目游戏的形式和内容。

### 5.1 游戏类型和类型要素

如今很难对一款现代游戏进行明确分类，一款A类型的游戏往往包含了很多B类型的要素。例如《塞尔达传说》（角色扮演、冒险、解谜），《无主之地》（第一人称设计、角色扮演），《刺客信条》（潜入、角色扮演、动作、平台跳跃）。当要讨论一个游戏的类型时，需要明确它最主要的类型和它所包含的类型要素。

本游戏为横版动作游戏，包含角色扮演、平台跳跃、解谜、类银河战士恶魔城等类型要素。下面介绍本游戏包含的主要游戏类型要素。

#### 5.1.1 横版动作

横版动作游戏首先是横版游戏。横版游戏，亦被称为横向卷轴游戏或横版闯关游戏。特色是游戏中角色通常由左方往右方移动，镜头（即玩家看到的屏幕画面）对着角色侧面，跟随着角色右移，右方陆续出现各种物品或角色。角色透过飞行与跳跃等也可以有限度地往上、下方向行动，但是只能微小程度或者完全不能靠近与远离镜头。例如《超级马里奥》里的主角不断往右方移动，利用跳跃或滑翔等方式通过障碍物，不断前进。在进入3D时代之前，动作游戏通常为此类。著名的横向卷轴游戏还有《洛克人》、《魔界村》、《索尼克》等。横版游戏的诞生得益于卷轴化技术的发明（《Defender》，1980年）。早期电子游戏的游戏场景局限于一个屏幕的大小之内，不同场景之间的切换是不连续的。而卷轴化技术让游戏场景在屏幕一侧消失，在另一侧拓展，从而极大地扩大了游戏场景，使得一些游戏类型有了实现的基础。

动作游戏是最早出现及最常见的游戏类型之一，动作游戏一般有关卡设计。提供玩家训练手眼协调及反应能力的环境，玩家必须操控游戏角色，根据周遭环境的变化，做出反应动作，例如移动、跳跃、攻击……等，并达到游戏设定的目标。动作游戏重点在于整体流畅性和刺激性，随着游戏硬件升级而持续进步，玩法和内容渐渐复杂并丰富。 广义来说，一切有动作要素的即时交互性游戏皆属于动作游戏。例如射击游戏、体育游戏；狭义则是以肢体打斗和冷兵器作为主要战斗方式的闯关类游戏。

#### 5.1.2 角色扮演

#### 5.1.3 平台跳跃

#### 5.1.4 解谜

#### 5.1.5 类银河战士恶魔城

### 5.2 游戏叙事和游戏交互

#### 5.2.1 剧情梗概

#### 5.2.2 交互系统

#### 5.2.3 叙事和交互的互相影响

### 5.3 游戏子系统设计

#### 5.3.1 攻击系统

#### 5.3.2 连段系统

#### 5.3.3 角色扮演要素

#### 5.3.4 平台跳跃设计

#### 5.3.5 解谜要素设计

#### 5.3.6 可反复探索的地图设计

#### 5.3.7 子系统的整合与统一

## 6 交互优化设计

本章分析玩家与游戏交互时影响交互体验的要素，并提出优化方案。

游戏交互即玩家与游戏程序之间的交流，途径有输入（键盘、鼠标、手柄按键等），和输出（显示设备、音效、手柄震动反馈等）。玩家下达指令，程序给予反馈，玩家根据反馈结果继续下达指令，形成交互循环。

交互有优劣之分。好的交互让玩家输入指令后获得理所当然的、符合预期的结果，也就是平时我们说的“手感好”，并且产生足够的反馈，使得游戏构建的世界真实可信。

本章从设计层面探讨动作游戏中的各种交互设计的优化方法。

### 6.1 操作自由

当玩家操控的角色会立即反馈玩家的指令，那么玩家的操作是自由的。

一般来讲，游戏操控越自由，玩家的体验会越好。而这样的自由会带来毛病：如果角色随时是可控的，那么角色的动作随时会被打断。从画面表现来讲，这样会导致角色动画的中断和不连贯，从游戏机制来讲，这样是不合理且不平衡的。例如：如果玩家可以在攻击动作之中传达攻击指令，那么角色就会不停重复攻击前摇动作而不进行攻击。或者角色会取消掉攻击后摇，瞬间造成大量伤害。这显然是不合理的。

完全的操作自由是灾难，而操作不自由又是令人沮丧的。因而要通过对指定状态指定操作的限制，让玩家在相对自由的状态下完成流畅的游戏体验，即需要合理地设计可控和不可控状态以及它们之间的转移。由此，本文将分析各玩家基本操作的交互逻辑以及设计优化。

### 6.2 移动机制

控制玩家移动是最基础的操作交互之一，移动机制根据游戏类型而定。一般来讲，3d游戏或2d俯视角游戏包含一个平面上若干方向的移动，而横版游戏的移动则一般局限于向左或向右的一维移动，通过跳跃等其他机制来进行更多维度的位置改变。

#### 6.2.1 移动方式和适用场景

移动机制有很多不同的类型，最简单的就是始终保持角色静止或匀速运动。

移动的实现有很多种方式。最简单的，直接控制角色的位置改变。例如：如果玩家按住“前进”键，那么在识别到该指令的游戏帧中，每一帧都会让角色位置向前改变固定的位置。这种方式是最直接简单的，对角色的操控是最强的，但也有很多不足之处。例如：不同的设备的游戏性能是不同的，这直接影响了游戏的帧率。在不同帧率下进行游戏，角色移动的速度就会不同，这是不合理的。此外还要进行各种分析：是否撞到墙上？是否站在地上？这些状态都会影响到移动的进行，必须进行捕捉和分析。这种方式使得角色的移动速度只有n或0两种可能。

#### 6.2.2 移动与攻击

#### 6.2.3 移动与其他状态

### 6.3 跳跃机制

在任何一款2D平台游戏中，如何设计跳跃机制将在极大程度上决定着游戏所呈现的感觉。对于具有平台跳跃要素的游戏来说，跳跃是玩家使用最频繁的能力之一，跳跃手感的好坏很大程度上决定了游戏整体手感的好坏。为此，设计良好的跳跃机制是必修的课题。

#### 6.3.1 真实跳跃模型

在现实世界中，理想情况下跳跃是一个斜抛运动，跳跃运动的位置曲线是一条抛物线，它完全取决于重力和起始速度。而在电子游戏中，玩家和设计者更关心跳跃的有效性和明确性，对角色跳跃能力的度量更加明确，即角色“能跳这么高，能跳这么远”，更少地关心跳跃曲线的真实性。

电子游戏的一些逻辑与现实世界略有不同。例如：挑战一个怪物需要玩家具有10点战斗力，如果玩家有15点战斗力，那么理应能够挑战成功，而没有任何额外的负面效果。同理，在电子游戏中“跳跃能力”也是一项可感知、可量化的能力属性，如果我具有10个单位的横向跳跃距离，那么我理应轻松地跳跃到达10单位距离以内的平台。如果使用真实跳跃模型，除了“跳跃距离”这个参数之外，我还需要关心跳跃初始速度、跳跃方向、起跳位置等等信息。这样的跳跃方式是降低游戏性的。

为了使跳跃机制更符合玩家预期、更具有游戏性，可以用多种方式调整跳跃模型。

#### 6.3.2 多变的跳跃高度

在几乎每一款平台跳跃游戏中，都有多变的跳跃高度的设定。平台跳跃游戏素来就有允许玩家通过持续或长或短地摁住跳跃键来改变跳跃高度的传统。这样玩家能够线性控制跳跃动作的高度和距离，使得小于跳跃能力的平台更容易到达。同时这种机制还会给予玩家额外的决策自由：例如《超级马里奥兄弟》中，当玩家轻击跳跃键时，可以获得迅速且高度不高的跳跃，可以用它来攻击（踩踏）敌人、连续顶起砖块等，而当玩家长按跳跃键时，则可以获得比较高和比较远的跳跃曲线，可以用来到达新的平台。

实现这一目标的常用方法就是在按下跳跃按钮时抑制重力，或让角色y轴速度恒定，令其达到特定的最大持续时间时回到斜抛运动。这会产生类似穿着喷气背包跳跃运动——其高度会线性增长直到加入重力因素为止，之后再转变为通常的抛物线。

#### 6.3.3 空中控制

在现实世界中，如果一个角色跳跃到半空中，那么他就是一个只受重力影响的封闭系统，也就是说，他跳跃离开地面的时候就已经确定了落点位置。在现代电子游戏中，为了游戏性提升，允许玩家控制跳跃中的角色是一个很常见的做法。在不允许空中控制的游戏中，如果玩家起跳失误，那么他没有挽回和补救的空间，只能看着角色滑向错误的地方，这无疑是令人沮丧的。早期具有平台跳跃元素的游戏中有很多不允许空中控制的游戏（例如《恶魔城》、《真人快打》等），这样的设定令玩家群体意见很大，要知道这些游戏开发的时候，《超级马里奥兄弟》早已发售并取得成功。

如今允许空中控制成为共识，但控制程度如何又需要根据具体游戏而定。例如《洛克人》系列允许玩家完全控制跳跃转向，即玩家在空中转向灵活度和横向移动速度与在地面无异。这是由游戏玩法决定的：《洛克人》中，玩家需要经常作出跳跃躲避子弹和障碍物等操作，这样一来玩家就需要极为精准可控的跳跃曲线；再比如《银河战士》、《超级马里奥兄弟》中，空中控制是有限的，玩家如果在空中转向，就会先减速，然后取得一个反向的速度。这两款游戏更注重平台跳跃玩法，第一次起跳的控制更为重要，而空中控制则是对失误的修正和缓冲。其次，这样的跳跃更有“重量感”，这样的“重量感”与“廉价感”相对应，是对游戏手感的一类感性概括。

#### 6.3.4 重力和跳跃高度

正如篮球运动员会在起跳最高点出手投篮一样，电子游戏中有许多动作可以在更高的位置上发挥更大的作用。例如刚才所说的空中控制，还有空中攻击、多级跳跃等。但“最高点”的时机稍纵即逝。如果滞空时间更长，玩家处在“最高点”的时间相应就会变长，此时更容易作出有利的决策。这样的设定与“子弹时间”等系统相类似，本质上都是增加玩家的决策时间，以此增加游戏体验。

在不改变跳跃高度的前提下，可通过改变角色重力的方式调整滞空时间。在通常的跳跃模型下，角色的时间-高度曲线应当是近似的抛物线，而增加滞空时间之后的曲线应当更“方”一些。即：在上升和下降阶段，角色所受重力较大，在滞空阶段，角色所受重力较小。

### 6.4 连段与取消

#### 6.4.1 前摇和后摇

一次攻击动画可分为三个阶段：前摇（准备阶段）、判定阶段（实际攻击发生阶段）和后摇（收招阶段）。前摇指攻击前的准备动作，例如举刀、蓄力等，这个阶段不会发生攻击判定。判定阶段指攻击有效的阶段，例如刀挥向敌人、出拳等，这个阶段会发生实际的攻击判定。后摇指攻击完成之后、返回待机状态之前的一段时间，例如收刀、收回拳头等。

一般来讲，前摇和后摇状态中角色是不可控制的。

#### 6.4.2 取消

“取消”这一概念一开始来自于格斗游戏，它指的是使用一个招式让另一个招式的后摇状态和动画终止，而直接进入下一个招式。“取消”系统最早出现于卡普空在1991年推出的《街头霸王2》。这个系统其实原本是偶然产物，在开发过程中一度被视为bug。通过在攻击过程输入必杀技指令从而强制结束收招动画，提前发动必杀技，以及跳跃攻击落地会强制结束硬直状态的机制，玩家创造出了新的套路和新的节奏，改变了格斗游戏的玩法。可以说“取消”系统是“连招”系统的基础。

取消分很多类型，最常见的是固定连段里的取消。例如

#### 6.4.3 连段在Unity下的实现

### 6.5 连段与取消的限制设计

如果连段与取消系统不加限制，那么当一个角色被另一个角色攻击，前者很可能通过不断用招式取消后摇的方式攻击对方，使对方一直处于受击状态，从而迅速结束战斗。这样的玩法是不健康的、不平衡的。本小节介绍什么是玩法平衡，以及如何限制取消系统。

#### 6.5.1 玩法平衡

如果一个游戏具有一个很容易找到的最优解或者近似最优解，那么这样的游戏很容易变得无聊。例如一个游戏里设计了一个攻击力最高、最安全且速度最快的招式，那么它会被玩家当作通关时主要使用的招式，而其他招式就很难被使用。为了使游戏变得有趣，有必要对玩法作出平衡设计与调整。

这里的“玩法”不单指单个招式，还广泛地指代了玩家游玩游戏时的方法和手段。例如交战时的位置选择、连招选择、武器装备选择、技能搭配选择、攻略路线等等。原则上来说，只要是给玩家提供选择的地方，都有必要让每一个备选项有一定竞争力。这里介绍动作游戏玩法平衡设计的一些原则和方法。

#### 6.5.2 简单无限连段的限制

如果玩家不断使用一个招式取消另一个招式的后摇，经过若干招式后达成循环，这样就形成了无限连段。在无限连段中，对手一直处于受击僵直状态无法还击，直到战斗结束。而“简单无限连段”指达成无限连段所需的步骤很少且很易行，即是“显然的最优解”。

是否限制无限连段以及简单无限连段是根据游戏类型和目的决定的。在玩家之间对抗的游戏中，一般对两种连段都有很强的限制，而玩家对抗电脑的游戏中一般对无限连段限制较弱，对简单无限连段限制较强。

对简单无限连段的限制的方法有很多，举例如下：

1. 早期FC游戏（如《双截龙》、《热血物语》系列）和一些街机横版清关游戏（如《恐龙快打》、《吞食天地》）中，一般会设计普通攻击连招的最后一下将敌人击飞，这样连招就会中断。
2. 一些格斗游戏里的普通攻击设计中，如果一轮普通攻击结束之后还要继续进行普通攻击，那么前一轮攻击的后摇时间会累加到下一轮攻击的前摇时间内，在对抗中处于天然劣势。
3. 如果游戏设计缺陷导致简单无限连段已经出现，例如《拳皇97》里八神庵的指令投无限连，那么玩家之间可达成协议，禁用一些招式或一些人物。
4. 一些游戏则会用其他游戏机制限制简单无限连。例如《鬼泣》系列，玩家得分取决于单位时间内使用招式的种类（连招华丽程度），这样使用简单无限连招会得到很低的分数。

对于一般的无限连段，或者说复杂无限连段，原则上讲是鼓励的，因为这是玩家技术的体现。所以在对抗电脑的游戏中一般不作限制，而玩家之间对抗的时候则需考虑另一玩家的游戏体验以及游戏平衡，所以会对无限连段作出限制。例如《地下城与勇士》中有如下几个措施：

1. 随着连招时间的增加，攻击造成的浮空高度会越来越小，导致连招难度越来越大。
2. 当单次连招造成伤害为玩家总生命值的三分之一时，会强制使一次攻击无效，让连招结束。
3. 玩家具有从受击状态中反击的招式。

对于无限连段的限制是否限制、如何限制，都要取决于游戏目的。本游戏为对抗电脑的单机游戏，其中不对无限连段做限制，对于简单无限连段的限制为：简单无限连段造成伤害较小，浮空高度低，难以连续使用。

#### 6.5.3 招式平衡

理想状态下，玩家进行游戏时会根据所处情况不同，合理选择不同招式应敌。而实际上总有一些“好用”的招式能够应对绝大多数情况，另一些“不好用”的招式则出场率不高。一个招式的好用与否，取决于它的各项性能参数，在不同的游戏类型中参数有所不同，在动作游戏中，常见的参数有：伤害值、速度、攻击范围、冷却值、资源消耗、浮空值、击退值、硬直、硬直抗性等等，此外还有一些与招式机制有关的参数，例如角色位移、强制取消等等。

对招式进行平衡，也就是对它的参数进行平衡，以期各个招式都有被使用的价值。例如：一个招式如果伤害值特别高，相应地，它的速度可能就会比较慢，前摇后摇也会比较长。例如《忍者龙剑传》中有一招从空中快速接近敌人的招式，它在攻击和逃跑的时候都非常有用，于是它的后摇被设置得很长，避免被玩家滥用；如果一个招式能强制取消大多数招式（例如翻滚或闪避），那么使用它的代价可能会比较大（花费较多法力值、高冷却时间等）。

此外还有增加额外系统的方式来进行招式平衡，例如，设计一系列各方面参数都很高的招式，同时设计一系列参数较低的招式，设置一种资源，当使用低参数招式时进行资源累积，当使用高参数招式时进行资源消耗。（例如《鬼泣》系列的魔人槽设定）这样的系统使得战斗节奏更加多样，同时也让各种招式都有使用的价值。

#### 6.5.4 取消限制

#### 6.5.5 鼓励多种连段方式

### 6.6 打击感和Unity下的实现

打击感，即“击中的感觉”，是玩家对一次攻击是否可信的评判。

#### 6.6.1 打击感的来源

打击感源于反馈。这种反馈是多方面的，

#### 6.6.2 增加打击感的方法

#### 6.6.3 攻击动画

#### 6.6.4 受击动画

#### 6.6.5 抽帧和减速

#### 6.6.6 抖动

#### 6.6.7 打击特效

#### 6.6.8 打击音效

#### 6.6.9 单次攻击多次判定

#### 6.6.10 镜头语言

### 6.7 难度设计

#### 6.7.1 心流

#### 6.7.2 数值设计

#### 6.7.3 暗示和引导

#### 6.7.4 动态难度

## 7 项目实现

本章叙述项目具体实现。包括项目文件结构、场景结构等偏向设计和约定的功能的具体实现，也包括各个子系统或者单一功能的具体实现。

### 7.1 项目文件结构

一个unity的项目根目录下包含Assets、Library、Logs、Packages、ProjectSettings、Temp等目录。根据目录名可以了解到他们各自的作用。在开发过程中，主要需要使用到的目录为Assets，这个文件夹存放了一切游戏所需要的素材文件，包括图片、脚本、预制件、场景等等。一般来讲Assets中文件和文件命名都是自由的。unity引擎会对所有文件夹和文件生产.meta文件，生成这个文件夹或文件的id，使得每一个使用该资源的其他资源能够找到唯一正确的路径。对于一些特殊的资源，例如图片资源，meta文件还会记录他的切片信息、缩放倍数等。在Assets中又有一类特殊的文件夹，它们的名字和功能都是固定的。以本文项目为例，现将Assets目录结构列举如下：

Assets

- Editor    编辑器类存放文件夹，这里用来存放第三方编辑器插件
- StreamingAssets    这个文件夹中的任何资源都将被原样复制到目标设备上的一个特定文件夹中。而其他文件夹中的内容会进行二进制压缩。把文件存放到这个文件夹的好处在于第三方的可扩展性，例如可以把游戏文本、一些ui贴图或者角色贴图放到这里，那么第三方开发者就很容易对里面的内容进行修改，从而制作mod或者语言本地化补丁等。
- Materials    材质球，材质信息包含shader和传入的参数。使用unity shader对gpu渲染过程（主要是顶点和片元渲染器）进行编辑，从而达到改变物体材质的目的。
- Prefabs    预制体，所有不需要Resource.Load加载的预制体，均存放在此。
- Resources    所有需要通过Resource.Load加载的资源都存放于此
- Audios    存放音频文件
- Images    贴图文件，2d
- Plugins    存放dll文件和一些纯代码插件
- Scenes    存放场景.scene文件
- Scripts    存放脚本代码

### 7.2 场景结构

如2.1所讲，场景的构建是自由的，没有特殊的限制，只要能完成应有的功能，并且使设计上尽量合理即可。以本文项目为例，现介绍项目的场景结构。

#### 7.2.1 宏观场景结构



### 7.3 游戏流程与场景切换

#### 7.3.1 游戏抽象流程

#### 7.3.2 场景切换方法

#### 7.3.3 切换场景时保存游戏数据

### 7.4 动画状态机

### 7.5 动画状态机脚本控制

### 7.6 镜头控制

### 7.7 特效控制

### 7.8 音效控制

### 7.9 技能发生器

当一个角色（玩家或非玩家）进行各类攻击指令时，将会创建一系列带有攻击碰撞框的游戏对象，为了代码复用，将创建技能的方法抽象为一个发生器，任何角色进行攻击动作时都会调用这一系列方法。

#### 7.9.1 近身攻击发生

近身攻击发生的特点是：除了各种形状的碰撞框之外，除了特效之外，没有其他的视觉表现。例如：角色进行出拳攻击，这时与攻击相关的只有出拳的动画，而没有其他的辅助表现的游戏对象。

#### 7.9.2 远程攻击发生

#### 7.9.3 投掷物的状态和动画

### 7.10 增益和减益状态控制

### 7.11 光照

使用unity内置光照系统，并利用脚本控制光照参数。

### 7.12 瓦片地图

### 7.13 视差滚动背景

### 7.14 UI控制

#### 7.14.1 HUD显示与控制

#### 7.15.2 UI菜单交互

### 7.15 对象之间的交互

#### 7.15.1 碰撞框与脚本控制

#### 7.15.2 分组碰撞

#### 7.15.3 各类对象默认交互能力

#### 7.15.4 碰撞特例与控制

### 7.16 攻击和受击

### 7.17 物品与掉落

### 7.18 敌人AI

#### 7.18.1 普通近战敌人

#### 7.18.2 普通远程敌人

#### 7.18.3 精英敌人

#### 7.18.4 boss

### 7.17 字体与国际化

#### 7.18 像素字体生成

#### 7.19 多语言扩展

#### 7.20 贴图替换支持

### 7.18 主界面与系统选项

### 7.19 存档与读档















